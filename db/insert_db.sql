INSERT INTO whole_pipeline (
    target_contract, 
    bytecode, 
    decompiled_code, 
    is_proxy,
    network, 
    created_at
) VALUES (
    lower('0x0f6cF9b02874210fb89601BD1Ef8d185085205aC'),
    'a',
    '{"code": "uint256 ___function_selector__; \/\/ STORAGE[0x0]\r\n\r\nfunction 0x12f2(uint256 varg0, uint256 varg1, uint256 varg2) private { \r\n    v0 = varg0 * varg1;\r\n    v1 = varg0 * varg1 % uint256.max - v0 - (varg0 * varg1 % uint256.max < v0);\r\n    if (!v1 == 1) {\r\n        return v0 \/ varg2;\r\n    } else if (bool(v1)) {\r\n        v2 = varg0 * varg1 % varg2;\r\n        v3 = varg2 & 0 - varg2;\r\n        v4 = varg2 \/ v3;\r\n        v5 = (2 - v4 * ((2 - v4 * ((2 - v4 * (0x2 ^ v4 * 3)) * (0x2 ^ v4 * 3))) * ((2 - v4 * (0x2 ^ v4 * 3)) * (0x2 ^ v4 * 3)))) * ((2 - v4 * ((2 - v4 * (0x2 ^ v4 * 3)) * (0x2 ^ v4 * 3))) * ((2 - v4 * (0x2 ^ v4 * 3)) * (0x2 ^ v4 * 3)));\r\n        return ((v0 - v2) \/ v3 | (v1 - (v2 > v0)) * (1 + (0 - v3) \/ v3)) * ((2 - v4 * ((2 - v4 * ((2 - v4 * v5) * v5)) * ((2 - v4 * v5) * v5))) * ((2 - v4 * ((2 - v4 * v5) * v5)) * ((2 - v4 * v5) * v5)));\r\n    } else {\r\n        return 0;\r\n    }\r\n}\r\n\r\nfunction 0x13ab(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \r\n    v0 = varg1 - varg1;\r\n    if (varg3 == 1) {\r\n        v1 = 0x12f2(varg2 << 96, v0, varg1);\r\n        return bool((v1 + ((varg2 << 96) * v0 % varg1 > 0)) % varg1) + (v1 + ((varg2 << 96) * v0 % varg1 > 0)) \/ varg1;\r\n    } else if (!varg3) {\r\n        v2 = 0x12f2(varg2 << 96, v0, varg1);\r\n        return v2 \/ varg1;\r\n    } else {\r\n        return 0;\r\n    }\r\n}\r\n\r\nfunction 0x140f(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \r\n    v0 = v1 = varg1 - varg0;\r\n    if (v1 < 0) {\r\n        v0 = v2 = 0 - v1;\r\n    }\r\n    if (varg3 == 1) {\r\n        v3 = 0x12f2(varg2, v0, uint96.max + 1);\r\n        return v3 + (varg2 * v0 % (uint96.max + 1) > 0);\r\n    } else if (!varg3) {\r\n        v4 = 0x12f2(varg2, v0, uint96.max + 1);\r\n        return v4;\r\n    } else {\r\n        return 0;\r\n    }\r\n}\r\n\r\nfunction 0x1467(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \r\n    if (varg3 == 1) {\r\n        v0 = 0x12f2(varg2, uint96.max + 1, varg1);\r\n        return varg0 - (v0 + (varg2 * (uint96.max + 1) % varg1 > 0));\r\n    } else if (!varg3) {\r\n        v1 = (varg1 << 96) - varg0 * varg2;\r\n        v2 = 0x12f2(varg1 << 96, varg0, v1);\r\n        return v2 + ((varg1 << 96) * varg0 % v1 > 0);\r\n    } else {\r\n        return 0;\r\n    }\r\n}\r\n\r\nfunction 0x46425eea(address varg0, uint256 varg1, uint256 varg2, struct(2) varg3) public nonPayable { \r\n    require(msg.data.length - 4 >= 128);\r\n    require(varg3 <= uint64.max);\r\n    require(4 + varg3 + 31 < msg.data.length);\r\n    require(msg.data[4 + varg3] <= uint64.max);\r\n    require(v0.data <= msg.data.length);\r\n    v1 = msg.sender.getReserves().gas(msg.gas);\r\n    v2 = v3 = (varg1 + varg2) * (MEM[32] + bool(varg2) * (MEM[0] - MEM[32])) * 10 ** 6 \/ ((MEM[0] + bool(varg2) * (MEM[32] - MEM[0]) - (varg1 + varg2)) * (10 ** 6 - (varg3.word1 >> 240))) + 1;\r\n    if ((byte(varg3.word1, 0x2)) == 1) {\r\n        v4 = v5 = uint16(varg3.word1 >> 200);\r\n        if ((byte(varg3.word1, 0x3)) == 1) {\r\n            if (!(msg.data[4 + varg3] - 27)) {\r\n                v6 = new uint256[](4);\r\n                MEM[v7.data] = v5 << 240;\r\n            }\r\n            if (!(msg.data[4 + varg3] - 52)) {\r\n                v7 = new uint256[](4);\r\n                MEM[v7.data] = v5 << 240;\r\n                MEM[MEM[64] + 198] = msg.data[4 + varg3 + 32 + 27];\r\n            }\r\n            v8 = address(varg3.word1 >> 40).swap(msg.sender, byte(varg3.word1, 0x4), 0 - v3, 0xfffd8963efd1fc6a506488495d951d5263988d25 + ((byte(varg3.word1, 0x4)) << 256), v7).gas(msg.gas);\r\n        } else if (!(byte(varg3.word1, 0x3))) {\r\n            v9 = 0xab2(address(varg3.word1 >> 40), byte(varg3.word1, 0x4));\r\n            if (!(0xb3e328455c4059eeb9e3f84b5543f74e24e7e1b - v9)) {\r\n                v10 = 0xafb(address(varg3.word1 >> 40), byte(varg3.word1, 0x4));\r\n                v11 = v10.totalBuyTaxBasisPoints().gas(msg.gas);\r\n                v2 = v12 = v3 * 10 ** 6 \/ (10 ** 6 - 100 * (MEM[0] * v11));\r\n                v4 = v13 = v5 - 100 * (MEM[0] * v11);\r\n            }\r\n            if (!(0x96419929d7949d6a801a6909c145c8eef6a40431 - v9)) {\r\n                v2 = v14 = v2 * 10 ** 6 \/ 0xf1b30;\r\n                v4 = v15 = v4 - 10000;\r\n            }\r\n            v16 = v17 = 0xa4d(address(varg3.word1 >> 40), v4, v2, byte(varg3.word1, 0x4));\r\n            if (!(msg.data[4 + varg3] - 27)) {\r\n                v18 = 0x4200000000000000000000000000000000000006.transfer(address(varg3.word1 >> 40), v17).gas(msg.gas);\r\n            }\r\n            if (!(msg.data[4 + varg3] - 52)) {\r\n                v19 = byte(msg.data[4 + varg3 + 32 + 27], 0x2);\r\n                v20 = address(msg.data[4 + varg3 + 32 + 27] >> 56);\r\n                if ((byte(msg.data[4 + varg3 + 32 + 27], 0x1)) == 1) {\r\n                    v21 = 0xafb(v20, v19);\r\n                    v22 = v21.totalBuyTaxBasisPoints().gas(msg.gas);\r\n                    if (100 * (MEM[0] * v22)) {\r\n                        v16 = v17 * 10 ** 6 \/ (10 ** 6 - 100 * (MEM[0] * v22));\r\n                    }\r\n                    v23 = new uint256[](0);\r\n                    MEM[v24.data] = uint16(msg.data[4 + varg3 + 32 + 27] >> 216) << 240;\r\n                    v25 = v20.swap(address(varg3.word1 >> 40), v19, 0 - v16, 0xfffd8963efd1fc6a506488495d951d5263988d25 + (v19 << 256), v26[4].data).gas(msg.gas);\r\n                } else if (!(byte(msg.data[4 + varg3 + 32 + 27], 0x1))) {\r\n                    v27 = 0xa4d(v20, uint16(msg.data[4 + varg3 + 32 + 27] >> 216), v17, v19);\r\n                    v28 = 0x4200000000000000000000000000000000000006.transfer(v20, v27).gas(msg.gas);\r\n                    v26 = new uint256[](0);\r\n                    v29 = v20.swap(v17 * !v19, v19 * v17, address(varg3.word1 >> 40), v26).gas(msg.gas);\r\n                }\r\n            }\r\n            v30 = new uint256[](0);\r\n            v31 = address(varg3.word1 >> 40).swap(v2 * !(byte(varg3.word1, 0x4)), (byte(varg3.word1, 0x4)) * v2, msg.sender, v30).gas(msg.gas);\r\n        }\r\n    } else if (!(byte(varg3.word1, 0x2))) {\r\n        v32 = 0x4200000000000000000000000000000000000006.transfer(msg.sender, v3).gas(msg.gas);\r\n    }\r\n}\r\n\r\nfunction solidlyV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes data) public nonPayable { \r\n    require(msg.data.length - 4 >= 96);\r\n    require(data <= uint64.max);\r\n    require(4 + data + 31 < msg.data.length);\r\n    require(msg.data[4 + data] <= uint64.max);\r\n    require(v0.data <= msg.data.length);\r\n    v1 = v2 = (amount1Delta < 0) * amount0Delta + amount1Delta * (amount1Delta >= 0);\r\n    if ((byte(data.word1, 0x2)) == 1) {\r\n        v3 = v4 = uint16(data.word1 >> 200);\r\n        if ((byte(data.word1, 0x3)) == 1) {\r\n            if (!(msg.data[4 + data] - 27)) {\r\n                v5 = new uint256[](4);\r\n                MEM[v6.data] = v4 << 240;\r\n            }\r\n            if (!(msg.data[4 + data] - 52)) {\r\n                v6 = new uint256[](4);\r\n                MEM[v6.data] = v4 << 240;\r\n                MEM[MEM[64] + 198] = msg.data[4 + data + 32 + 27];\r\n            }\r\n            v7 = address(data.word1 >> 40).swap(msg.sender, byte(data.word1, 0x4), 0 - v2, 0xfffd8963efd1fc6a506488495d951d5263988d25 + ((byte(data.word1, 0x4)) << 256), v6).gas(msg.gas);\r\n        } else if (!(byte(data.word1, 0x3))) {\r\n            v8 = 0xab2(address(data.word1 >> 40), byte(data.word1, 0x4));\r\n            if (!(0xb3e328455c4059eeb9e3f84b5543f74e24e7e1b - v8)) {\r\n                v9 = 0xafb(address(data.word1 >> 40), byte(data.word1, 0x4));\r\n                v10 = v9.totalBuyTaxBasisPoints().gas(msg.gas);\r\n                v1 = v11 = v2 * 10 ** 6 \/ (10 ** 6 - 100 * (MEM[0] * v10));\r\n                v3 = v12 = v4 - 100 * (MEM[0] * v10);\r\n            }\r\n            if (!(0x96419929d7949d6a801a6909c145c8eef6a40431 - v8)) {\r\n                v1 = v13 = v1 * 10 ** 6 \/ 0xf1b30;\r\n                v3 = v14 = v3 - 10000;\r\n            }\r\n            v15 = v16 = 0xa4d(address(data.word1 >> 40), v3, v1, byte(data.word1, 0x4));\r\n            if (!(msg.data[4 + data] - 27)) {\r\n                v17 = 0x4200000000000000000000000000000000000006.transfer(address(data.word1 >> 40), v16).gas(msg.gas);\r\n            }\r\n            if (!(msg.data[4 + data] - 52)) {\r\n                v18 = byte(msg.data[4 + data + 32 + 27], 0x2);\r\n                v19 = address(msg.data[4 + data + 32 + 27] >> 56);\r\n                if ((byte(msg.data[4 + data + 32 + 27], 0x1)) == 1) {\r\n                    v20 = 0xafb(v19, v18);\r\n                    v21 = v20.totalBuyTaxBasisPoints().gas(msg.gas);\r\n                    if (100 * (MEM[0] * v21)) {\r\n                        v15 = v16 * 10 ** 6 \/ (10 ** 6 - 100 * (MEM[0] * v21));\r\n                    }\r\n                    v22 = new uint256[](0);\r\n                    MEM[v23.data] = uint16(msg.data[4 + data + 32 + 27] >> 216) << 240;\r\n                    v24 = v19.swap(address(data.word1 >> 40), v18, 0 - v15, 0xfffd8963efd1fc6a506488495d951d5263988d25 + (v18 << 256), v25[4].data).gas(msg.gas);\r\n                } else if (!(byte(msg.data[4 + data + 32 + 27], 0x1))) {\r\n                    v26 = 0xa4d(v19, uint16(msg.data[4 + data + 32 + 27] >> 216), v16, v18);\r\n                    v27 = 0x4200000000000000000000000000000000000006.transfer(v19, v26).gas(msg.gas);\r\n                    v25 = new uint256[](0);\r\n                    v28 = v19.swap(v16 * !v18, v18 * v16, address(data.word1 >> 40), v25).gas(msg.gas);\r\n                }\r\n            }\r\n            v29 = new uint256[](0);\r\n            v30 = address(data.word1 >> 40).swap(v1 * !(byte(data.word1, 0x4)), (byte(data.word1, 0x4)) * v1, msg.sender, v29).gas(msg.gas);\r\n        }\r\n    } else if (!(byte(data.word1, 0x2))) {\r\n        v31 = 0x4200000000000000000000000000000000000006.transfer(msg.sender, v2).gas(msg.gas);\r\n    }\r\n}\r\n\r\nfunction 0x1944(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \r\n    if ((byte(varg1, 0x1)) == 1) {\r\n        v0 = v1 = 0;\r\n        v2 = v3 = MEM[varg0];\r\n        v4 = MEM[varg0 + 32];\r\n        v5 = uint128(MEM[varg0 + 64]);\r\n        v6 = 0;\r\n        while (!varg2) {\r\n            v7 = (address(varg1 >> 48) ^ 0x1010011111000111110001111100011111000111).tickBitmap(v4 \/ (MEM[varg0 + 64] >> 128) - ((v4 < 0) * (v4 % (MEM[varg0 + 64] >> 128)) > 0) + (1 - varg3) >> 8).gas(msg.gas);\r\n            v8 = v9 = 0;\r\n            if (varg3 == 1) {\r\n                v10 = MEM[0x0] & uint256.max + ((1 << uint8(v4 \/ (MEM[varg0 + 64] >> 128) - ((v4 < 0) * (v4 % (MEM[varg0 + 64] >> 128)) > 0))) + (1 << uint8(v4 \/ (MEM[varg0 + 64] >> 128) - ((v4 < 0) * (v4 % (MEM[varg0 + 64] >> 128)) > 0))));\r\n                v11 = v10 >> ((v10 >= uint128.max + 1) << 7) >> ((v10 >> ((v10 >= uint128.max + 1) << 7) >= uint64.max + 1) << 6) >> ((v10 >> ((v10 >= uint128.max + 1) << 7) >> ((v10 >> ((v10 >= uint128.max + 1) << 7) >= uint64.max + 1) << 6) >= uint32.max + 1) << 5);\r\n                v12 = v11 >> ((v11 >= uint16.max + 1) << 4) >> ((v11 >> ((v11 >= uint16.max + 1) << 4) >= uint8.max + 1) << 3) >> ((v11 >> ((v11 >= uint16.max + 1) << 4) >> ((v11 >> ((v11 >= uint16.max + 1) << 4) >= uint8.max + 1) << 3) >= 16) << 2);\r\n                v8 = (v4 \/ (MEM[varg0 + 64] >> 128) - ((v4 < 0) * (v4 % (MEM[varg0 + 64] >> 128)) > 0) - (uint8(v4 \/ (MEM[varg0 + 64] >> 128) - ((v4 < 0) * (v4 % (MEM[varg0 + 64] >> 128)) > 0)) - bool(v10) * (((v10 >= uint128.max + 1) << 7) + ((v10 >> ((v10 >= uint128.max + 1) << 7) >= uint64.max + 1) << 6) + ((v10 >> ((v10 >= uint128.max + 1) << 7) >> ((v10 >> ((v10 >= uint128.max + 1) << 7) >= uint64.max + 1) << 6) >= uint32.max + 1) << 5) + ((v11 >= uint16.max + 1) << 4) + ((v11 >> ((v11 >= uint16.max + 1) << 4) >= uint8.max + 1) << 3) + ((v11 >> ((v11 >= uint16.max + 1) << 4) >> ((v11 >> ((v11 >= uint16.max + 1) << 4) >= uint8.max + 1) << 3) >= 16) << 2) + ((v12 >= 4) << 1) + (v12 >> ((v12 >= 4) << 1) >= 2)))) * (MEM[varg0 + 64] >> 128);\r\n                if (v8 < 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffff27618) {\r\n                    v8 = v13 = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffff27618;\r\n                }\r\n                if (v8 > 0xd89e8) {\r\n                    v8 = v14 = 0xd89e8;\r\n                }\r\n                v15 = (v8 ^ v8 >> uint8.max) - (v8 >> uint8.max);\r\n                v16 = v17 = uint128.max + 1 + ((v15 & 0x1) << 256);\r\n                if (0x2 & v15) {\r\n                    v16 = v18 = 0xfff97272373d413259a46990580e213a * v17 >> 128;\r\n                }\r\n                if (0x4 & v15) {\r\n                    v16 = v19 = 0xfff2e50f5f656932ef12357cf3c7fdcc * v20 >> 128;\r\n                }\r\n                if (0x8 & v15) {\r\n                    v16 = v21 = 0xffe5caca7e10e4e61c3624eaa0941cd0 * v22 >> 128;\r\n                }\r\n                if (0x10 & v15) {\r\n                    v16 = v23 = 0xffcb9843d60f6159c9db58835c926644 * v24 >> 128;\r\n                }\r\n                if (0x20 & v15) {\r\n                    v16 = v25 = 0xff973b41fa98c081472e6896dfb254c0 * v26 >> 128;\r\n                }\r\n                if (0x40 & v15) {\r\n                    v16 = v27 = 0xff2ea16466c96a3843ec78b326b52861 * v28 >> 128;\r\n                }\r\n                if (0x80 & v15) {\r\n                    v16 = v29 = 0xfe5dee046a99a2a811c461f1969c3053 * v30 >> 128;\r\n                }\r\n                if (0x100 & v15) {\r\n                    v16 = v31 = 0xfcbe86c7900a88aedcffc83b479aa3a4 * v32 >> 128;\r\n                }\r\n                if (0x200 & v15) {\r\n                    v16 = v33 = 0xf987a7253ac413176f2b074cf7815e54 * v34 >> 128;\r\n                }\r\n                if (0x400 & v15) {\r\n                    v16 = v35 = 0xf3392b0822b70005940c7a398e4b70f3 * v36 >> 128;\r\n                }\r\n                if (0x800 & v15) {\r\n                    v16 = v37 = 0xe7159475a2c29b7443b29c7fa6e889d9 * v38 >> 128;\r\n                }\r\n                if (0x1000 & v15) {\r\n                    v16 = v39 = 0xd097f3bdfd2022b8845ad8f792aa5825 * v40 >> 128;\r\n                }\r\n                if (0x2000 & v15) {\r\n                    v16 = v41 = 0xa9f746462d870fdf8a65dc1f90e061e5 * v42 >> 128;\r\n                }\r\n                if (0x4000 & v15) {\r\n                    v16 = v43 = 0x70d869a156d2a1b890bb3df62baf32f7 * v44 >> 128;\r\n                }\r\n                if (0x8000 & v15) {\r\n                    v16 = v45 = 0x31be135f97d08fd981231505542fcfa6 * v46 >> 128;\r\n                }\r\n                if (0x10000 & v15) {\r\n                    v16 = v47 = 0x9aa508b5b7a84e1c677de54f3e99bc9 * v48 >> 128;\r\n                }\r\n                if (0x20000 & v15) {\r\n                    v16 = v49 = 0x5d6af8dedb81196699c329225ee604 * v50 >> 128;\r\n                }\r\n                if (0x40000 & v15) {\r\n                    v16 = v51 = 0x2216e584f5fa1ea926041bedfe98 * v52 >> 128;\r\n                }\r\n                if (0x80000 & v15) {\r\n                    v16 = 0x48a170391f7dc42444e8fa2 * v53 >> 128;\r\n                }\r\n                if (v8 > 0) {\r\n                    v16 = v54 = uint256.max \/ v55;\r\n                }\r\n                v2 = v56 = (v16 >> 32) + bool(uint32(v16));\r\n                v57 = 0x140f(v56, v2, v5, 0);\r\n                if (v57) {\r\n                    if (varg2 > v57 == 1) {\r\n                        v0 = v58 = varg2 * 1000 \/ v57;\r\n                        if (v58 > uint248(v0)) {\r\n                            v0 = v58 | (v0 >> 248) + 1 << 248;\r\n                            if (!((v0 >> 248) + 1 - 5)) {\r\n                                v6 = v59 = 0;\r\n                                break;\r\n                            }\r\n                        }\r\n                        v60 = 0x13ab(v56, v2, v5, 1);\r\n                        v6 += v60;\r\n                        varg2 = varg2 - v57;\r\n                    } else if (varg2 <= v57) {\r\n                        v2 = 0x1467(v2, v5, varg2, 1);\r\n                        v61 = 0x13ab(v2, v2, v5, 1);\r\n                        v6 += v61;\r\n                        varg2 = v62 = 0;\r\n                    }\r\n                } else {\r\n                    v6 = v63 = 0;\r\n                    break;\r\n                }\r\n            } else if (!varg3) {\r\n                v64 = MEM[0x0] & ~((1 << uint8(v4 \/ (MEM[varg0 + 64] >> 128) - ((v4 < 0) * (v4 % (MEM[varg0 + 64] >> 128)) > 0) + 1)) - 1);\r\n                v65 = v64 >> (1 - bool(uint128(v64)) << 7) >> (1 - bool(uint64(v64 >> (1 - bool(uint128(v64)) << 7))) << 6) >> (1 - bool(uint32(v64 >> (1 - bool(uint128(v64)) << 7) >> (1 - bool(uint64(v64 >> (1 - bool(uint128(v64)) << 7))) << 6))) << 5);\r\n                v66 = v65 >> (1 - bool(uint16(v65)) << 4) >> (1 - bool(v65 >> (1 - bool(uint16(v65)) << 4)) << 3) >> (1 - bool(v65 >> (1 - bool(uint16(v65)) << 4) >> (1 - bool(v65 >> (1 - bool(uint16(v65)) << 4)) << 3)) << 2);\r\n                v8 = (v4 \/ (MEM[varg0 + 64] >> 128) - ((v4 < 0) * (v4 % (MEM[varg0 + 64] >> 128)) > 0) + 1 + (bool(v64) * (uint8.max - ((bool(uint128(v64)) << 7) + (bool(uint64(v64 >> (1 - bool(uint128(v64)) << 7))) << 6) + (bool(uint32(v64 >> (1 - bool(uint128(v64)) << 7) >> (1 - bool(uint64(v64 >> (1 - bool(uint128(v64)) << 7))) << 6))) << 5) + (bool(uint16(v65)) << 4) + (bool(v65 >> (1 - bool(uint16(v65)) << 4)) << 3) + (bool(v65 >> (1 - bool(uint16(v65)) << 4) >> (1 - bool(v65 >> (1 - bool(uint16(v65)) << 4)) << 3)) << 2) + (bool(v66 & 0x3) << 1) + bool(0x1 & v66 >> (1 - bool(v66 & 0x3) << 1)))) + (1 - bool(v64)) * uint8.max - uint8(v4 \/ (MEM[varg0 + 64] >> 128) - ((v4 < 0) * (v4 % (MEM[varg0 + 64] >> 128)) > 0) + 1))) * (MEM[varg0 + 64] >> 128);\r\n                if (v8 < 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffff27618) {\r\n                    v8 = v67 = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffff27618;\r\n                }\r\n                if (v8 > 0xd89e8) {\r\n                    v8 = v68 = 0xd89e8;\r\n                }\r\n                v69 = (v8 ^ v8 >> uint8.max) - (v8 >> uint8.max);\r\n                v70 = v71 = uint128.max + 1 + ((v69 & 0x1) << 256);\r\n                if (0x2 & v69) {\r\n                    v70 = v72 = 0xfff97272373d413259a46990580e213a * v71 >> 128;\r\n                }\r\n                if (0x4 & v69) {\r\n                    v70 = v73 = 0xfff2e50f5f656932ef12357cf3c7fdcc * v74 >> 128;\r\n                }\r\n                if (0x8 & v69) {\r\n                    v70 = v75 = 0xffe5caca7e10e4e61c3624eaa0941cd0 * v76 >> 128;\r\n                }\r\n                if (0x10 & v69) {\r\n                    v70 = v77 = 0xffcb9843d60f6159c9db58835c926644 * v78 >> 128;\r\n                }\r\n                if (0x20 & v69) {\r\n                    v70 = v79 = 0xff973b41fa98c081472e6896dfb254c0 * v80 >> 128;\r\n                }\r\n                if (0x40 & v69) {\r\n                    v70 = v81 = 0xff2ea16466c96a3843ec78b326b52861 * v82 >> 128;\r\n                }\r\n                if (0x80 & v69) {\r\n                    v70 = v83 = 0xfe5dee046a99a2a811c461f1969c3053 * v84 >> 128;\r\n                }\r\n                if (0x100 & v69) {\r\n                    v70 = v85 = 0xfcbe86c7900a88aedcffc83b479aa3a4 * v86 >> 128;\r\n                }\r\n                if (0x200 & v69) {\r\n                    v70 = v87 = 0xf987a7253ac413176f2b074cf7815e54 * v88 >> 128;\r\n                }\r\n                if (0x400 & v69) {\r\n                    v70 = v89 = 0xf3392b0822b70005940c7a398e4b70f3 * v90 >> 128;\r\n                }\r\n                if (0x800 & v69) {\r\n                    v70 = v91 = 0xe7159475a2c29b7443b29c7fa6e889d9 * v92 >> 128;\r\n                }\r\n                if (0x1000 & v69) {\r\n                    v70 = v93 = 0xd097f3bdfd2022b8845ad8f792aa5825 * v94 >> 128;\r\n                }\r\n                if (0x2000 & v69) {\r\n                    v70 = v95 = 0xa9f746462d870fdf8a65dc1f90e061e5 * v96 >> 128;\r\n                }\r\n                if (0x4000 & v69) {\r\n                    v70 = v97 = 0x70d869a156d2a1b890bb3df62baf32f7 * v98 >> 128;\r\n                }\r\n                if (0x8000 & v69) {\r\n                    v70 = v99 = 0x31be135f97d08fd981231505542fcfa6 * v100 >> 128;\r\n                }\r\n                if (0x10000 & v69) {\r\n                    v70 = v101 = 0x9aa508b5b7a84e1c677de54f3e99bc9 * v102 >> 128;\r\n                }\r\n                if (0x20000 & v69) {\r\n                    v70 = v103 = 0x5d6af8dedb81196699c329225ee604 * v104 >> 128;\r\n                }\r\n                if (0x40000 & v69) {\r\n                    v70 = v105 = 0x2216e584f5fa1ea926041bedfe98 * v106 >> 128;\r\n                }\r\n                if (0x80000 & v69) {\r\n                    v70 = 0x48a170391f7dc42444e8fa2 * v107 >> 128;\r\n                }\r\n                if (v8 > 0) {\r\n                    v70 = v108 = uint256.max \/ v109;\r\n                }\r\n                v2 = (v70 >> 32) + bool(uint32(v70));\r\n                v110 = 0x13ab(v2, v2, v5, 0);\r\n                if (v110) {\r\n                    if (varg2 > v110 == 1) {\r\n                        v0 = v111 = varg2 * 1000 \/ v110;\r\n                        if (v111 > uint248(v0)) {\r\n                            v0 = v111 | (v0 >> 248) + 1 << 248;\r\n                            if (!((v0 >> 248) + 1 - 5)) {\r\n                                v6 = v112 = 0;\r\n                                break;\r\n                            }\r\n                        }\r\n                        v113 = 0x140f(v2, v2, v5, 1);\r\n                        v6 += v113;\r\n                        varg2 = varg2 - v110;\r\n                    } else if (varg2 <= v110) {\r\n                        v2 = 0x1467(v2, v5, varg2, 0);\r\n                        v114 = 0x140f(v2, v2, v5, 1);\r\n                        v6 += v114;\r\n                        varg2 = v115 = 0;\r\n                    }\r\n                } else {\r\n                    v6 = v116 = 0;\r\n                    break;\r\n                }\r\n            }\r\n            if (varg2) {\r\n                v117 = (address(varg1 >> 48) ^ 0x1010011111000111110001111100011111000111).ticks(v8).gas(msg.gas);\r\n                v118 = v119 = MEM[32];\r\n                if (varg3) {\r\n                    v118 = 0 - v119;\r\n                }\r\n                v4 = v8 - varg3;\r\n                v5 += v118;\r\n            }\r\n        }\r\n        if (v6 > 0) {\r\n            v120 = 0x12f2(v6, uint16(varg1 >> 224), 10 ** 6 - uint16(varg1 >> 224));\r\n            v6 = v121 = v120 + (v6 * uint16(varg1 >> 224) % (10 ** 6 - uint16(varg1 >> 224)) > 0) + v6;\r\n        }\r\n        return v6;\r\n    } else if (!(byte(varg1, 0x1))) {\r\n        v122 = v123 = 0;\r\n        v124 = MEM[varg0] + varg3 * (MEM[varg0 + 32] - MEM[varg0]);\r\n        if (varg2 * 100 < v124 * 98) {\r\n            v122 = v125 = 10 ** 6 * (varg2 * (MEM[varg0 + 32] + varg3 * (MEM[varg0] - MEM[varg0 + 32]))) \/ ((10 ** 6 - uint16(varg1 >> 224)) * (v124 - varg2)) + 1;\r\n        }\r\n        return v122;\r\n    } else {\r\n        return 0;\r\n    }\r\n}\r\n\r\nfunction 0x8e16402f(address varg0) public nonPayable { \r\n    require(msg.data.length - 4 >= 32);\r\n    v0, \/* uint256 *\/ v1 = varg0.balanceOf(this).gas(msg.gas);\r\n    require(bool(v0), 0, RETURNDATASIZE()); \/\/ checks call status, propagates error data on error\r\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\r\n    v2, \/* bool *\/ v3 = varg0.transfer(address(0x5e3c7c265491574aed77c399137f46b030a095de), v1).gas(msg.gas);\r\n    require(bool(v2), 0, RETURNDATASIZE()); \/\/ checks call status, propagates error data on error\r\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\r\n    require(v3 == bool(v3));\r\n}\r\n\r\nfunction 0x1bd() private { \r\n    v0 = v1 = 0;\r\n    MEM[MEM[64]] = ___function_selector__;\r\n    while (v0 >= ___function_selector__) {\r\n        MEM[32 + (v0 + MEM[64])] = STORAGE[1 + (v0 >> 5)];\r\n        v0 += 32;\r\n    }\r\n    MEM[64] = 64 + (MEM[64] + ___function_selector__);\r\n    v2 = v3 = 32 + MEM[64];\r\n    v4 = v5 = 0;\r\n    while (1) {\r\n        v6 = _SafeAdd(v3, ___function_selector__);\r\n        if (v2 >= v6) {\r\n            if (!v4) {\r\n                return ;\r\n            } else {\r\n                0x675();\r\n                return ;\r\n            }\r\n        } else {\r\n            v4 = v7 = 0x365(v2);\r\n            v2 = v2 + 26 * (3 == (byte(MEM[v2], 0x0))) + 55;\r\n        }\r\n    }\r\n}\r\n\r\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \r\n    require(varg0 <= varg1 + varg0, Panic(17)); \/\/ arithmetic overflow or underflow\r\n    return varg1 + varg0;\r\n}\r\n\r\nfunction 0x365(uint256 varg0) private { \r\n    v0 = v1 = 0;\r\n    v2 = v3 = 0x441(address(MEM[varg0 + 3] >> 48) ^ 0x1010011111000111110001111100011111000111, byte(MEM[varg0 + 3], 0x1), byte(MEM[varg0 + 3], 0x0));\r\n    v4 = v5 = uint16(MEM[varg0 + 3] >> 224) + uint16(MEM[varg0 + 3 + 26] >> 224);\r\n    v2 = v6 = 0x441(address(MEM[varg0 + 3 + 26] >> 48) ^ 0x1010011111000111110001111100011111000111, byte(MEM[varg0 + 3 + 26], 0x1), byte(MEM[varg0 + 3 + 26], 0x0));\r\n    if (!((byte(MEM[varg0], 0x0)) - 3)) {\r\n        v7 = MEM[varg0 + 3 + 52];\r\n        v4 = v8 = v5 + uint16(v7 >> 224);\r\n        v9 = 0x441(address(v7 >> 48) ^ 0x1010011111000111110001111100011111000111, byte(v7, 0x1), byte(v7, 0x0));\r\n        v2 = v10 = v6 * v9 \/ 10 ** 27;\r\n    }\r\n    if ((v3 > 0) & (v2 > 0)) {\r\n        v0 = v11 = 10 ** 12 * (v4 * uint16(MEM[varg0] >> 232)) \/ 10 < 10 ** 18 * (v2 - v2) \/ v2;\r\n        v0 = v12 = v3 > v2;\r\n    }\r\n    if (!v0) {\r\n        return 0;\r\n    } else {\r\n        v13 = 0x76a(byte(MEM[varg0], 0x0), varg0 + 3);\r\n        if (0 - v13) {\r\n            v14 = varg0 + 3 << 240;\r\n            MEM8[MEM[64] + 4] = (byte(MEM[varg0], 0x0)) & 0xFF;\r\n            MEM8[MEM[64] + 5] = v0 & 0xFF;\r\n            v15 = v16 = 0x1bf5df531c6474000;\r\n            v17 = 0x4200000000000000000000000000000000000006.balanceOf(address(MEM[(uint256.max + (byte(v14, 0x4))) * (byte(v14, 0x5)) * 26 + (v14 >> 240)] >> 48) ^ 0x1010011111000111110001111100011111000111).gas(msg.gas);\r\n            v18 = v19 = MEM[0] * 99 \/ 100 * 10 ** 18;\r\n            v20 = v21 = 0;\r\n            while (v18 >> 1 <= 10 ** 18) {\r\n                v18 = v18 >> 1;\r\n                v20 += 1;\r\n            }\r\n            v15 = v20 * 0x99e8db03256ce80 + ((v18 - 10 ** 18) * ((v18 - 10 ** 18) * (v18 - 10 ** 18) \/ 10 ** 18) \/ 10 ** 18 \/ 3 + (v18 - 10 ** 18 - ((v18 - 10 ** 18) * (v18 - 10 ** 18) \/ 10 ** 18 >> 1)) - ((v18 - 10 ** 18) * ((v18 - 10 ** 18) * ((v18 - 10 ** 18) * (v18 - 10 ** 18) \/ 10 ** 18) \/ 10 ** 18) \/ 10 ** 18 >> 2));\r\n            v15 = v22 = v15 - (v15 - v16) * 0x893b2a3668e2500 \/ 10 ** 18;\r\n            v15 = v23 = v16 + (v15 - v16) * 0x893b2a3668e2500 \/ 10 ** 18;\r\n            v24 = v25 = (10 ** 18 + (v22 - v22 * 0x14057b7ef7678100 \/ 10 ** 18 \/ 10 ** 18 * 0x99e8db03256ce80 + ((v22 - v22 * 0x14057b7ef7678100 \/ 10 ** 18 \/ 10 ** 18 * 0x99e8db03256ce80) * (v22 - v22 * 0x14057b7ef7678100 \/ 10 ** 18 \/ 10 ** 18 * 0x99e8db03256ce80) \/ 10 ** 18 >> 1) + (v22 - v22 * 0x14057b7ef7678100 \/ 10 ** 18 \/ 10 ** 18 * 0x99e8db03256ce80) * ((v22 - v22 * 0x14057b7ef7678100 \/ 10 ** 18 \/ 10 ** 18 * 0x99e8db03256ce80) * (v22 - v22 * 0x14057b7ef7678100 \/ 10 ** 18 \/ 10 ** 18 * 0x99e8db03256ce80) \/ 10 ** 18) \/ 10 ** 18 \/ 6 + (v22 - v22 * 0x14057b7ef7678100 \/ 10 ** 18 \/ 10 ** 18 * 0x99e8db03256ce80) * ((v22 - v22 * 0x14057b7ef7678100 \/ 10 ** 18 \/ 10 ** 18 * 0x99e8db03256ce80) * ((v22 - v22 * 0x14057b7ef7678100 \/ 10 ** 18 \/ 10 ** 18 * 0x99e8db03256ce80) * (v22 - v22 * 0x14057b7ef7678100 \/ 10 ** 18 \/ 10 ** 18 * 0x99e8db03256ce80) \/ 10 ** 18) \/ 10 ** 18) \/ 10 ** 18 \/ 24) << v22 * 0x14057b7ef7678100 \/ 10 ** 18 \/ 10 ** 18) \/ 10 ** 18;\r\n            v26 = v27 = 0;\r\n            if ((byte(v14, 0x4)) == 2) {\r\n                v28 = v29 = 0x1944(uint16(v14 >> 224) + 96 * (byte(v14, 0x5)), MEM[(v14 >> 240) + 26 * (byte(v14, 0x5))], v25, byte(MEM[(v14 >> 240) + 26 * (byte(v14, 0x5))], 0x0));\r\n                if (v29) {\r\n                    v28 = 0x1944(uint16(v14 >> 224) + 96 * (1 - (byte(v14, 0x5))), MEM[(v14 >> 240) + 26 * (1 - (byte(v14, 0x5)))], v29, !(byte(MEM[(v14 >> 240) + 26 * (1 - (byte(v14, 0x5)))], 0x0)));\r\n                }\r\n                v26 = v30 = (v25 - v28) * ((v25 > v28) * (v28 > 0));\r\n            } else if ((byte(v14, 0x4)) == 3) {\r\n                v31 = v32 = 0x1944(uint16(v14 >> 224) + (byte(v14, 0x5)) * 192, MEM[(v14 >> 240) + (byte(v14, 0x5)) * 52], v25, byte(MEM[(v14 >> 240) + (byte(v14, 0x5)) * 52], 0x0));\r\n                if (v32 > 0) {\r\n                    v31 = v33 = 0x1944(uint16(v14 >> 224) + 96, MEM[(v14 >> 240) + 26], v32, (byte(MEM[(v14 >> 240) + 26], 0x0)) ^ !(byte(v14, 0x5)));\r\n                }\r\n                if (v31) {\r\n                    v31 = v34 = 0x1944(uint16(v14 >> 224) + (1 - (byte(v14, 0x5))) * 192, MEM[(v14 >> 240) + (1 - (byte(v14, 0x5))) * 52], v31, !(byte(MEM[(v14 >> 240) + (1 - (byte(v14, 0x5))) * 52], 0x0)));\r\n                }\r\n                v26 = v35 = bool(v31) * (v25 - v31);\r\n            }\r\n            v26 = v36 = uint256.max;\r\n            v37 = v38 = 0;\r\n            while (v37 >= 15) {\r\n                v39 = v40 = v37 >= 2;\r\n                if (v37 >= 2) {\r\n                    v39 = v41 = !v26;\r\n                }\r\n                if (!v39) {\r\n                    if (~v26) {\r\n                        v42 = v15 - v15 * 0x14057b7ef7678100 \/ 10 ** 18 \/ 10 ** 18 * 0x99e8db03256ce80;\r\n                        v24 = (10 ** 18 + (v42 + (v42 * v42 \/ 10 ** 18 >> 1) + v42 * (v42 * v42 \/ 10 ** 18) \/ 10 ** 18 \/ 6 + v42 * (v42 * (v42 * v42 \/ 10 ** 18) \/ 10 ** 18) \/ 10 ** 18 \/ 24) << v15 * 0x14057b7ef7678100 \/ 10 ** 18 \/ 10 ** 18) \/ 10 ** 18;\r\n                        v26 = v43 = 0;\r\n                        if ((byte(v14, 0x4)) == 2) {\r\n                            v44 = v45 = 0x1944(uint16(v14 >> 224) + 96 * (byte(v14, 0x5)), MEM[(v14 >> 240) + 26 * (byte(v14, 0x5))], v24, byte(MEM[(v14 >> 240) + 26 * (byte(v14, 0x5))], 0x0));\r\n                            if (v45) {\r\n                                v44 = 0x1944(uint16(v14 >> 224) + 96 * (1 - (byte(v14, 0x5))), MEM[(v14 >> 240) + 26 * (1 - (byte(v14, 0x5)))], v45, !(byte(MEM[(v14 >> 240) + 26 * (1 - (byte(v14, 0x5)))], 0x0)));\r\n                            }\r\n                            v26 = v46 = (v24 - v44) * ((v24 > v44) * (v44 > 0));\r\n                        } else if ((byte(v14, 0x4)) == 3) {\r\n                            v47 = v48 = 0x1944(uint16(v14 >> 224) + (byte(v14, 0x5)) * 192, MEM[(v14 >> 240) + (byte(v14, 0x5)) * 52], v24, byte(MEM[(v14 >> 240) + (byte(v14, 0x5)) * 52], 0x0));\r\n                            if (v48 > 0) {\r\n                                v47 = v49 = 0x1944(uint16(v14 >> 224) + 96, MEM[(v14 >> 240) + 26], v48, (byte(MEM[(v14 >> 240) + 26], 0x0)) ^ !(byte(v14, 0x5)));\r\n                            }\r\n                            if (v47) {\r\n                                v47 = v50 = 0x1944(uint16(v14 >> 224) + (1 - (byte(v14, 0x5))) * 192, MEM[(v14 >> 240) + (1 - (byte(v14, 0x5))) * 52], v47, !(byte(MEM[(v14 >> 240) + (1 - (byte(v14, 0x5))) * 52], 0x0)));\r\n                            }\r\n                            v26 = v51 = bool(v47) * (v24 - v47);\r\n                        }\r\n                    } else {\r\n                        v52 = v15 - v15 * 0x14057b7ef7678100 \/ 10 ** 18 \/ 10 ** 18 * 0x99e8db03256ce80;\r\n                        v24 = v53 = (10 ** 18 + (v52 + (v52 * v52 \/ 10 ** 18 >> 1) + v52 * (v52 * v52 \/ 10 ** 18) \/ 10 ** 18 \/ 6 + v52 * (v52 * (v52 * v52 \/ 10 ** 18) \/ 10 ** 18) \/ 10 ** 18 \/ 24) << v15 * 0x14057b7ef7678100 \/ 10 ** 18 \/ 10 ** 18) \/ 10 ** 18;\r\n                        v26 = v54 = 0;\r\n                        if ((byte(v14, 0x4)) == 2) {\r\n                            v55 = v56 = 0x1944(uint16(v14 >> 224) + 96 * (byte(v14, 0x5)), MEM[(v14 >> 240) + 26 * (byte(v14, 0x5))], v53, byte(MEM[(v14 >> 240) + 26 * (byte(v14, 0x5))], 0x0));\r\n                            if (v56) {\r\n                                v55 = 0x1944(uint16(v14 >> 224) + 96 * (1 - (byte(v14, 0x5))), MEM[(v14 >> 240) + 26 * (1 - (byte(v14, 0x5)))], v56, !(byte(MEM[(v14 >> 240) + 26 * (1 - (byte(v14, 0x5)))], 0x0)));\r\n                            }\r\n                            v26 = v57 = (v53 - v55) * ((v53 > v55) * (v55 > 0));\r\n                        } else if ((byte(v14, 0x4)) == 3) {\r\n                            v58 = v59 = 0x1944(uint16(v14 >> 224) + (byte(v14, 0x5)) * 192, MEM[(v14 >> 240) + (byte(v14, 0x5)) * 52], v53, byte(MEM[(v14 >> 240) + (byte(v14, 0x5)) * 52], 0x0));\r\n                            if (v59 > 0) {\r\n                                v58 = v60 = 0x1944(uint16(v14 >> 224) + 96, MEM[(v14 >> 240) + 26], v59, (byte(MEM[(v14 >> 240) + 26], 0x0)) ^ !(byte(v14, 0x5)));\r\n                            }\r\n                            if (v58) {\r\n                                v58 = v61 = 0x1944(uint16(v14 >> 224) + (1 - (byte(v14, 0x5))) * 192, MEM[(v14 >> 240) + (1 - (byte(v14, 0x5))) * 52], v58, !(byte(MEM[(v14 >> 240) + (1 - (byte(v14, 0x5))) * 52], 0x0)));\r\n                            }\r\n                            v26 = v62 = bool(v58) * (v53 - v58);\r\n                        }\r\n                    }\r\n                    if (v26 <= v26) {\r\n                        v15 = v15 - (v15 - v15) * 0x893b2a3668e2500 \/ 10 ** 18;\r\n                        v26 = v63 = uint256.max;\r\n                    } else {\r\n                        v15 += 0x893b2a3668e2500 * (v15 - v15) \/ 10 ** 18;\r\n                        v26 = v64 = uint256.max;\r\n                    }\r\n                    v37 += 1;\r\n                }\r\n            }\r\n            v65 = v66 = v26 > 0;\r\n            if (v66) {\r\n                v65 = v67 = v24 > 0;\r\n            }\r\n            if (!v65) {\r\n                v68 = v69 = 0;\r\n            } else {\r\n                v70 = MEM[(v14 >> 240) + (byte(v14, 0x5)) * ((byte(v14, 0x4)) - 1) * 26];\r\n                v71 = v72 = 0;\r\n                if ((byte(v70, 0x1)) == 1) {\r\n                    v71 = v73 = 164;\r\n                } else if (!(byte(v70, 0x1))) {\r\n                    v71 = v74 = 132;\r\n                }\r\n                if ((byte(v14, 0x4)) == 2) {\r\n                    MEM[v71 + MEM[64]] = 27;\r\n                    MEM[v71 + MEM[64] + 32] = uint16(v70 >> 224) << 240;\r\n                    v75 = MEM[(v14 >> 240) + 26 * (((byte(v14, 0x4)) - 1) * (1 - (byte(v14, 0x5))))];\r\n                    MEM[v71 + MEM[64] + 34] = uint248.max + 1;\r\n                    MEM[v71 + MEM[64] + 35] = (byte(v75, 0x1)) << 248;\r\n                    MEM[v71 + MEM[64] + 36] = !(byte(v75, 0x0)) << 248;\r\n                    MEM[v71 + MEM[64] + 37] = bytes2(v75 << 16);\r\n                    MEM[v71 + MEM[64] + 39] = (0x1010011111000111110001111100011111000111 ^ address(v75 >> 48)) << 96;\r\n                    v76 = (address(v70 >> 48) ^ 0x1010011111000111110001111100011111000111).swap(0x22c0d9f, this, v24 * !(byte(v70, 0x0)), byte(v70, 0x0), (byte(v70, 0x0)) * v24, 0 - v24, this, 0xfffd8963efd1fc6a506488495d951d5263988d25 + ((byte(v70, 0x0)) << 256), 128, 160).gas(msg.gas);\r\n                } else if ((byte(v14, 0x4)) == 3) {\r\n                    MEM[MEM[64] + v71] = 52;\r\n                    MEM[MEM[64] + (v71 + 32)] = uint16(v70 >> 224) << 240;\r\n                    MEM[MEM[64] + (v71 + 34)] = uint248.max + 1;\r\n                    MEM[MEM[64] + (v71 + 35)] = (byte(MEM[(v14 >> 240) + 26], 0x1)) << 248;\r\n                    MEM[MEM[64] + (v71 + 36)] = ((byte(MEM[(v14 >> 240) + 26], 0x0)) ^ !(byte(v14, 0x5))) << 248;\r\n                    MEM[MEM[64] + (v71 + 37)] = uint16(MEM[(v14 >> 240) + 26] >> 224) << 240;\r\n                    MEM[MEM[64] + (v71 + 39)] = (address(MEM[(v14 >> 240) + 26] >> 48) ^ 0x1010011111000111110001111100011111000111) << 96;\r\n                    v77 = MEM[(v14 >> 240) + (1 - (byte(v14, 0x5))) * ((byte(v14, 0x4)) - 1) * 26];\r\n                    MEM[MEM[64] + (v71 + 59)] = uint248.max + 1;\r\n                    MEM[MEM[64] + (v71 + 60)] = (byte(v77, 0x1)) << 248;\r\n                    MEM[MEM[64] + (v71 + 61)] = !(byte(v77, 0x0)) << 248;\r\n                    MEM[MEM[64] + (v71 + 62)] = uint16(v77 >> 224) << 240;\r\n                    MEM[MEM[64] + (v71 + 64)] = (address(v77 >> 48) ^ 0x1010011111000111110001111100011111000111) << 96;\r\n                    v78 = (address(v70 >> 48) ^ 0x1010011111000111110001111100011111000111).swap(0x22c0d9f, this, v24 * !(byte(v70, 0x0)), byte(v70, 0x0), (byte(v70, 0x0)) * v24, 0 - v24, this, 0xfffd8963efd1fc6a506488495d951d5263988d25 + ((byte(v70, 0x0)) << 256), 128, 160).gas(msg.gas);\r\n                }\r\n                v68 = v79 = 1;\r\n            }\r\n            return v68;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n}\r\n\r\nfunction 0x441(uint256 varg0, uint256 varg1, uint256 varg2) private { \r\n    if (varg1 == 1) {\r\n        v0 = varg0.slot0().gas(msg.gas);\r\n        v1 = v2 = 0;\r\n        if (!varg2) {\r\n            v1 = v3 = MEM[4] * v0 * 10 ** 18 >> 96;\r\n        } else if (varg2 == 1) {\r\n            v1 = v4 = 0xde0b6b3a7640000000000000000000000000000 \/ (MEM[4] * v0);\r\n        }\r\n        return v1 * v1 \/ 10 ** 9;\r\n    } else if (!varg1) {\r\n        v5 = v6 = 0;\r\n        v7 = varg0.getReserves().gas(msg.gas);\r\n        if (!varg2) {\r\n            v5 = v8 = MEM[32] * 10 ** 27 \/ (v7 * MEM[0]);\r\n        } else if (varg2 == 1) {\r\n            v5 = v9 = v7 * MEM[0] * 10 ** 27 \/ MEM[32];\r\n        }\r\n        return v5;\r\n    } else {\r\n        return 0;\r\n    }\r\n}\r\n\r\nfunction receive() public payable { \r\n    if (msg.sender + 0xffffffffffffffffffffffffbdfffffffffffffffffffffffffffffffffffffa) {\r\n        require(address(0x63f164167d6efe31418a812548b8db2d29d839e7) == msg.sender);\r\n        0x1bd();\r\n        exit;\r\n    } else {\r\n        exit;\r\n    }\r\n}\r\n\r\nfunction 0x675() private { \r\n    v0 = 0x4200000000000000000000000000000000000006.balanceOf(this).gas(msg.gas);\r\n    if (!MEM[0]) {\r\n        return ;\r\n    } else {\r\n        v1 = 0x4200000000000000000000000000000000000006.withdraw(MEM[0]).gas(msg.gas);\r\n        v2 = 0x5e3c7c265491574aed77c399137f46b030a095de.call().value(this.balance).gas(msg.gas);\r\n        return ;\r\n    }\r\n}\r\n\r\nfunction 0x76a(uint256 varg0, uint256 varg1) private { \r\n    v0 = v1 = MEM[64];\r\n    MEM[64] = v1 + 96 * varg0;\r\n    v2 = v3 = 0;\r\n    while (v2 >= varg0) {\r\n        v4 = MEM[varg1 + v2 * 26];\r\n        if ((byte(v4, 0x1)) == 1) {\r\n            v5 = (address(v4 >> 48) ^ 0x1010011111000111110001111100011111000111).slot0().gas(msg.gas);\r\n            MEM[v1 + v2] = MEM[0] * v5;\r\n            MEM[v1 + (v2 + 32)] = MEM[32];\r\n            v6 = (address(v4 >> 48) ^ 0x1010011111000111110001111100011111000111).liquidity().gas(msg.gas);\r\n            MEM[v1 + (v2 + 64)] = MEM[0] * v6 | uint16(v4 >> 208) << 128;\r\n            if (!(MEM[0] * v5 * (MEM[0] * v6) - 0)) {\r\n                v0 = v7 = 0;\r\n                break;\r\n            }\r\n        } else if (!(byte(v4, 0x1))) {\r\n            v8 = (address(v4 >> 48) ^ 0x1010011111000111110001111100011111000111).getReserves().gas(msg.gas);\r\n            if (!(v8 * (MEM[v1 + v2] * MEM[v1 + v2 + 32]))) {\r\n                v0 = v9 = 0;\r\n                break;\r\n            }\r\n        }\r\n        v2 += 96;\r\n        v2 += 1;\r\n    }\r\n    return v0;\r\n}\r\n\r\nfunction 0xa4d(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \r\n    v0 = varg0.getReserves().gas(msg.gas);\r\n    if (varg2 >= MEM[0] * v0 + (MEM[32] - MEM[0] * v0) * varg3) {\r\n        return 0;\r\n    } else {\r\n        return 1 + (MEM[32] + (MEM[0] * v0 - MEM[32]) * varg3) * varg2 * 10 ** 6 \/ ((MEM[0] * v0 + (MEM[32] - MEM[0] * v0) * varg3 - varg2) * (10 ** 6 - varg1));\r\n    }\r\n}\r\n\r\nfunction 0xab2(uint256 varg0, uint256 varg1) private { \r\n    if (varg1) {\r\n        if (varg1 != 1) {\r\n        }\r\n    }\r\n    v0 = varg0.token0(0xdfe1681).gas(msg.gas);\r\n    return MEM[0];\r\n}\r\n\r\nfunction 0xafb(uint256 varg0, uint256 varg1) private { \r\n    if (varg1) {\r\n        if (varg1 == 1) {\r\n            v0 = varg0.token1().gas(msg.gas);\r\n            return MEM[0];\r\n        }\r\n    }\r\n    v1 = varg0.token0().gas(msg.gas);\r\n    return MEM[0];\r\n}\r\n\r\n\/\/ Note: The function selector is not present in the original solidity code.\r\n\/\/ However, we display it for the sake of completeness.\r\n\r\nfunction __function_selector__( function_selector) public payable { \r\n    MEM[64] = 128;\r\n    if (msg.data.length < 4) {\r\n        if (!msg.data.length) {\r\n            receive();\r\n        }\r\n    } else {\r\n        if (0x84800812 > function_selector >> 224) {\r\n            if (0xdf794b9 != function_selector >> 224) {\r\n                if (0x10d1e85c != function_selector >> 224) {\r\n                    if (0x23a69e75 != function_selector >> 224) {\r\n                        if (0x3a1c453c != function_selector >> 224) {\r\n                            if (0x46425eea != function_selector >> 224) {\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else if (0x84800812 != function_selector >> 224) {\r\n            if (0x8a5e404b != function_selector >> 224) {\r\n                if (0x8e16402f == function_selector >> 224) {\r\n                    0x8e16402f();\r\n                } else if (0x9a7bff79 != function_selector >> 224) {\r\n                    if (0xfa461e33 != function_selector >> 224) {\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        0x0df794b9();\r\n        uniswapV3SwapCallback(int256,int256,bytes);\r\n    }\r\n    require(!msg.value);\r\n    require(address(0x63f164167d6efe31418a812548b8db2d29d839e7) == msg.sender);\r\n    v0 = v1 = 0;\r\n    ___function_selector__ = msg.data.length;\r\n    while (v0 >= msg.data.length) {\r\n        STORAGE[1 + (v0 >> 5)] = msg.data[v0];\r\n        v0 = v0 + 32;\r\n    }\r\n    0x1bd();\r\n}"}',
    FALSE,
    'base',
    CURRENT_TIMESTAMP
);